<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Goalkeeper]]></title>
  <subtitle><![CDATA[一份耕耘一份收获]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://walk-code.github.io/"/>
  <updated>2016-10-10T07:28:15.815Z</updated>
  <id>http://walk-code.github.io/</id>
  
  <author>
    <name><![CDATA[walk-code]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[浅用Laravel-Dingo构建restful-Api]]></title>
    <link href="http://walk-code.github.io/2016/10/10/%E6%B5%85%E7%94%A8Laravel-Dingo%E6%9E%84%E5%BB%BArestful-Api/"/>
    <id>http://walk-code.github.io/2016/10/10/浅用Laravel-Dingo构建restful-Api/</id>
    <published>2016-10-10T06:40:47.000Z</published>
    <updated>2016-10-10T07:28:15.815Z</updated>
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>最近一段时间在用php(第二好的语言)在折腾后台，从一开始”某人叫我必须要用thinkphp开发开始”一直的用TP来写接口,到后来我发现TP的的一些规范让我觉得恶心以外，更多的是用它来真的不好写restful风格的api，直到我遇见的<a href="https://github.com/dingo/api/wiki/Creating-API-Endpoints" target="_blank" rel="external">Dingo</a>+<a href="https://github.com/laravel/laravel" target="_blank" rel="external">laravel</a>这两个组合，大大的加快了开发的效率。Dingo提供了为我们提供了restful风格的api，自己可以制定返回参数，在wiki上都能找到，下面我是的项目目录结构：  </p>
<h2 id="<!-_more_->"><a id="more"></a></h2><p>  *#### 1.概述<br><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f8ksv6hotzj306l04wgm0.jpg" alt="project structure"></p>
<p>Controller这个文件夹就不需要多讲了，来看看Requests文件夹，里面主要是用来对前端传递过来的数据进行判断，自己根据自己的业务逻辑来制定判定的规则，一下面这张图来看:  </p>
<p><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f8kt08ob54j30bh08sjrw.jpg" alt="project class">  </p>
<p>authorize这个函数里做了一下权限的判断，rules这个函数就是根据自己的业务需求来制定自己想要的判定规则。前提是这个类必须继承FormRequest这个类，这个类是Dingo的一个用来做表单数据判断的类，里面有两个函数failedValidation和failedAuthorization，从函数名可以看出一个是用来校验错误后返回错误的信息，另一个则用来判断是否有授权，FormRequest还有个父类，这个父类实现了ValidatesWhenResolved这个接口，为我们提供了一下对数据判断的方法。</p>
<p>讲了了这么多最重要的还是要有数据，Transformers这个文件夹主要功能就是对数据进行返回，也就是产出者。还是照惯例给出一张图：  </p>
<p><img src="http://ww2.sinaimg.cn/large/005yEbTbgw1f8kt9cwom6j30hg0ekdj7.jpg" alt="project class">  </p>
<p>核心的函数transform中可以看出，我没有做太多的东西，只是根据数据库的字段全部填写上去(根据自己的业务逻辑)，这个类必须得继承TransformerAbstract这个抽象类，打开这个抽象类就会发现这么一段话  </p>
<p><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1f8lygqowdvj30kd05pq3y.jpg" alt="project class">  </p>
<p>大概的意思就是所有的数据转化的类都必须继承TransformerAbstract这个抽象类，这是为了能使用collection()和item()这两个方法，顾名思义前者是返回一个集合，后者则是返回一条记录。继承这个抽象类，必须实现transform()方法，用来返回你所需要的数据。</p>
<blockquote>
<p>至于为什么要用到transform(）这个方法，我在TransformerAbstract这个抽象类中并未找到这个抽象的方法。(待解决)  </p>
</blockquote>
<hr>
<h3 id="鉴权">鉴权</h3><h4 id="1-基本概念">1.基本概念</h4><p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token" target="_blank" rel="external">JWT简介</a><br>JWT-workflow 一图胜千言:<br><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1f8n44jfv83j31120ksq4y.jpg" alt="">  </p>
<h4 id="2-配置">2.配置</h4><p>说到后台，最主要还是鉴权，后台必须规定调用者应该登录后才能有权限去对服务器的资源进行请求，否则不予许其请求，JWT(json web token是一种网络的令牌)Dingo里面已经封装好了。虽然dingo里面已经包含了jwt,但是本着折腾的心我还是使用<a href="https://github.com/tymondesigns/jwt-auth/wiki/Installation" target="_blank" rel="external">tymondesigns的jwt-auth开源库</a>,跟着文档配置完就OK了，配置成功后config文件夹会有个jwt.php的配置文件，可以根据自己的业务需求来制定token的生命时间，默认是一小时内失效。refresh_token的时间则是是两周。</p>
<h4 id="3-设计思路">3.设计思路</h4><p>接口设计用户登录之后分配一个accessToken和一个refreshToken，accessToken用于发起用户请求，refreshToken用于更新accessToken。accessToken会设置有效期，可以设为24小时。而用户退出登录之后，accessToken和refreshToken都将作废。重新登录之后会分配新的accessToken和refreshToken。用户凭借着这个accessToken来向服务器请求资源。  </p>
<h4 id="4-一些安全(未做)">4.一些安全(未做)</h4><p>现在大多数的网站都采用<a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="external">HTTPS协议</a>,那就必须把HTTP协议升级到HTTP/2，<a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="external">阮一峰大大</a>，还有一些对安全性要求较高的数据，并未有做处理，mark<a href="http://keeganlee.me/post/practice/20160812" target="_blank" rel="external">API安全设计</a>  </p>
<hr>
<h3 id="总结">总结</h3><p>基本上就可以做一些简单的接口开发.</p>
<hr>
<h3 id="参考">参考</h3><p><em><a href="https://www.sitepoint.com/how-to-build-an-api-only-jwt-powered-laravel-app/" target="_blank" rel="external">blog</a>  
</em><a href="https://www.alwayscoder.com/using-laravel-and-dingo-build-your-restful-api/" target="_blank" rel="external">alwayscoder-blog</a><br><em><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="external">https</a>  
</em><a href="https://github.com/layer7be/vue-starter-laravel-api" target="_blank" rel="external">laravel+dingo</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="前言">前言</h3><p>最近一段时间在用php(第二好的语言)在折腾后台，从一开始”某人叫我必须要用thinkphp开发开始”一直的用TP来写接口,到后来我发现TP的的一些规范让我觉得恶心以外，更多的是用它来真的不好写restful风格的api，直到我遇见的<a href="https://github.com/dingo/api/wiki/Creating-API-Endpoints">Dingo</a>+<a href="https://github.com/laravel/laravel">laravel</a>这两个组合，大大的加快了开发的效率。Dingo提供了为我们提供了restful风格的api，自己可以制定返回参数，在wiki上都能找到，下面我是的项目目录结构：  </p>
<h2 id="<!-_more_->">]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[SeasLog的基本使用]]></title>
    <link href="http://walk-code.github.io/2016/07/24/SeasLog%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://walk-code.github.io/2016/07/24/SeasLog的基本使用/</id>
    <published>2016-07-24T01:47:08.000Z</published>
    <updated>2016-07-24T02:30:53.748Z</updated>
    <content type="html"><![CDATA[<h2 id="SeasLog简介">SeasLog简介</h2><p>SeasLog是一个日志的拓展,日志作为系统或者软件、应用的运行记录。通过对日志进行分析，可以让我们更好的了解应用的运行情况，也可以逐步的对用户的操作、用户习惯进行分析，从而优化，对于应用中的问题，能快速的得到定位，方便Developer解决。<br><a id="more"></a></p>
<h2 id="为什么要使用SeasLog">为什么要使用SeasLog</h2><p>php内置error_log、syslog函数功能强大且性能极好，但由于各种缺陷(error_log无错误级别、无固定格式，syslog不分模块、与系统日志混合)，灵活度降低了很多，不能满足应用需求。  </p>
<p>好消息是，有不少第三方的log类库弥补了上述缺陷，如log4php、plog、Analog等(当然也有很多应用在项目中自己开发的log类)。其中以log4php最为著名，设计精良、格式完美、文档完善、功能强大。推荐。  </p>
<p>不过log4php在性能方面表现非常差,下图是SeasLog与log4php的ab并发性能测试( 测试环境:Ubuntu12.04单机,CPU I3,内存 16G,硬盘 SATA 7200)<br>以下引用@<a href="https://github.com/Neeke" target="_blank" rel="external">Neeke</a>的统计第三方(log4php)性能测试的一组图  </p>
<p><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1f64sh6r3o6j30lz0ac0tc.jpg&quot;性能测试&quot;" alt="性能测试">  </p>
<p>那么有没有一种log类库满足以下需求呢: </p>
<ul>
<li>分模块、分级别  </li>
<li>配置简单(最好是勿须配置)  </li>
<li>日志格式清晰易读</li>
<li>应用简单、性能很棒  </li>
</ul>
<p>SeasLog 正是应此需求而生。  </p>
<hr>
<p>根据tips可以这样写,基于thinkphp,目录结构ThinkPHP\Library\Vendor\SeasLog\Logs.class.php：  </p>
<pre><code class="python">&lt;?php

namespace Vendor\SeasLog;
/*
 * author kylin
 * data 2016-7-17
 * */

class Logs
{

    /**
     * 获取访问者的ip 请求的uri
     *
     * return 访问者的ip 请求的uri     ip_address | request_uri
     */
    static public function getIpUri() {
        return $_SERVER['REMOTE_ADDR'] . ' | ' . $_SERVER['REQUEST_URI'] . ' | ';
    }

    /**
     * 设置日志的根路径
     * @param $basePath
     *
     * */
    static public function setBasePath($basePath) {
        \SeasLog::setBasePath($basePath);
    }

    /**
     *获取日志的根路径
     *
     * retrun string
     * */
    static public function getBasePath() {
        return \SeasLog::getBasePath();
    }

    /**
     * 设置模块目录
     * @param $module
     *
     * */
    static public function setLogger($module) {
        \SeasLog::setLogger($module);
    }

    /**
     * 获取最后一次的设置的模块
     * return string
     *
     * */
    static public function getLastLogger() {
        return \SeasLog::getLastLogger();
    }

    /**
     *统计所有类型（或单个类型）行数
     * @param string $level
     * @param string $log_path
     * @param null $key_word
     *
     * @return array | long
     * */
    static public function analyzerCount($level = 'all', $log_path = '*', $key_word = NULL) {
        return array();
    }

    /**
     * 以数组形式，快速取出某类型log的各行详情
     *
     * @param        $level
     * @param string $log_path
     * @param null $key_word
     * @param int $start
     * @param int $limit
     * @param        $order 默认为正序 SEASLOG_DETAIL_ORDER_ASC，可选倒序 SEASLOG_DETAIL_ORDER_DESC
     *
     * @return array
     */
    static public function analyzerDetail($level = SEASLOG_INFO, $log_path = '*', $key_word = NULL, $start = 1, $limit = 20, $order = SEASLOG_DETAIL_ORDER_ASC){
        return SeasLog::analyzerDetail($level = SEASLOG_INFO, $log_path = '*', $key_word = NULL, $start = 1, $limit = 20, $order = SEASLOG_DETAIL_ORDER_ASC);
    }

    /**
     * 获取当前日志的Buffer的内容
     * return array
     * */
    static public function getBuffer() {
        return getBuffer();
    }

    /**
     * 将buffer中的日志立刻刷到硬盘
     *
     * @return bool
     */
    static public function flushBuffer(){
        return true;
    }

    /**
     * 记录debug日志
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function debug($message,array $content = array(),$module = ''){

        #$level = SEASLOG_DEBUG
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::debug($message,$content,$module);
    }

    /**
     * 记录info日志
     * @param $message
     * @param array $content
     * @param string $module
     *
     * */
    static public function info($message,array $content = array(),$module = '') {

        #$level = SEASLOG_INFO
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::info($message,$content,$module);
    }

    /**
     * 记录notice日志
     * @param $message
     * @param array $content
     * @param string $module
     *
     * */
    static public function notice($message,array $content = array(),$module = '') {

        #$level = SEASLOG_NOTICE
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::notice($message,$content,$module);
    }

    /**
     * 记录warning日志
     * @param $message
     * @param array  $content
     * @param string $module
     * */
    static public function warning($message,array $content = array(),$module = '') {

        #$level = SEASLOG_WARNING
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::warning($message,$content,$module);
    }

    /**
     * 记录error日志
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function error($message,array $content = array(),$module = '') {

        #$level = SEASLOG_ERROR
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::error($message,$content,$module);
    }

    /**
     * 记录critical日志
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function critical($message,array $content = array(),$module = '') {

        #$level = SEASLOG_CRITICAL
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::critical($message,$content,$module);
    }

    /**
     * 记录alert日志
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function alert($message,array $content = array(),$module = '') {

        #$level = SEASLOG_ALERT
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::alert($message,$content,$module);
    }

    /**
     * 记录emergency日志
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function emergency($message,array $content = array(),$module = '') {

        #$level = SEASLOG_EMERGENCY
        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::emergency($message,$content,$module);
    }

    /**
     * 通用日志方法
     * @param $level
     * @param $message
     * @param array $content
     * @param string $module
     */
    static public function log($level,$message,array $content = array(),$module = '') {

        $message = self::getIpUri().$message;
        if($module !== ''){
            $module = $_SERVER['SERVER_NAME'].'/'.$module;
        }
        \SeasLog::log($level,$message,$content,$module);
    }

}
</code></pre>
<h3 id="附">附</h3><p>@Neeke <a href="https://github.com/Neeke/SeasLog]" target="_blank" rel="external">https://github.com/Neeke/SeasLog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SeasLog简介">SeasLog简介</h2><p>SeasLog是一个日志的拓展,日志作为系统或者软件、应用的运行记录。通过对日志进行分析，可以让我们更好的了解应用的运行情况，也可以逐步的对用户的操作、用户习惯进行分析，从而优化，对于应用中的问题，能快速的得到定位，方便Developer解决。<br>]]>
    
    </summary>
    
      <category term="PHP日志拓展" scheme="http://walk-code.github.io/tags/PHP%E6%97%A5%E5%BF%97%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅用GreenDao]]></title>
    <link href="http://walk-code.github.io/2016/05/29/%E6%B5%85%E7%94%A8GreenDao/"/>
    <id>http://walk-code.github.io/2016/05/29/浅用GreenDao/</id>
    <published>2016-05-29T04:41:43.000Z</published>
    <updated>2016-05-29T06:40:36.567Z</updated>
    <content type="html"><![CDATA[<h2 id="GreenDao官方简介">GreenDao官方简介</h2><p>greenDAO is an open source library for Android providing an easy to use interface to SQLite databases to help developers handle data efficiently – relieving developers from dealing with low-level database requirements while saving development time. SQLite is an awesome embedded relational database. Still, writing SQL and parsing query results are quite tedious and time-consuming tasks. greenDAO frees you from these by mapping Java objects to database tables (often called ORM). This way you can store, update, delete, and query for Java objects using a simple object oriented API.</p>
<h2 id="<!-more_->"><a id="more"></a></h2><h3 id="GreenDao思维导图(关系映射(ORM))">GreenDao思维导图(关系映射(ORM))</h3><p><img src="http://ww4.sinaimg.cn/large/005yEbTbgw1f4c5vwqsoqj308w02k0su.jpg" alt="思维导图"></p>
<h3 id="自动生成GreedDAO资源()">自动生成GreedDAO资源()</h3><p><img src="http://ww2.sinaimg.cn/large/005yEbTbgw1f4c67jcxjnj30hs08m400.jpg" alt="自动生成GreedDAO资源"></p>
<p>如果我们需要在项目中使用GreenDao，那么就需要我们创建一个新的Java Project,用于自动生成Bean、DAO、DaoMaster、DaoSession类。</p>
<h3 id="关于DAO、DaoMaster、DaoSession、Entity流程">关于DAO、DaoMaster、DaoSession、Entity流程</h3><p><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1f4c6g1qc8pj304607kmxd.jpg" alt="流程图"></p>
<p><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f4c6gqbdrxj305006rq30.jpg" alt="流程图"></p>
<p>通过流程图可以看出Dao类操作Entity类，而DaoSession是负责创建和管理Dao类，DaoSession是由DaoMaster负责创建的。可以看出当我们在对数据库进行操作时，为了避免创建多个DaoMaster和DaoSession,可以在继承applacation类中(程序入口)，定义一个全局变量。例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        create DaoMaster</span><br><span class="line"><span class="decorator">        @param context</span></span><br><span class="line"><span class="decorator">        @return</span></span><br><span class="line">     */</span><br><span class="line">    public static DaoMaster getDaoMaster(Context context) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (null == daoMaster) &#123;</span><br><span class="line"></span><br><span class="line">            DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context,DATABASE_NAME,null);</span><br><span class="line">            daoMaster = new DaoMaster(helper.getWritableDatabase());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> daoMaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        get DaoSession</span><br><span class="line"><span class="decorator">        @param context</span></span><br><span class="line"><span class="decorator">        @return</span></span><br><span class="line">     */</span><br><span class="line">    public static DaoSession getDaoSession(Context context) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (null == daoSession) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (null == daoMaster) &#123;</span><br><span class="line">                daoMaster = getDaoMaster(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            daoSession = daoMaster.newSession();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> daoSession;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本配置">基本配置</h2><h3 id="一-在android工程中配置GreenDao_Code_Generation模块">一.在android工程中配置GreenDao Code Generation模块</h3><p>1.在 .src/main 目录下新建一个与 java同层级的「java-gen」目录，用于存放由 greenDAO 生成的 Bean、DAO、DaoMaster、DaoSession 等类。<br><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f4c79i9txmj309703y74e.jpg" alt="流程图"></p>
<p>2.配置 Android 工程（app）的 build.gradle，如图分别添加 sourceSets 与 dependencies。<br><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1f4c7blimymj30hs0f2ade.jpg" alt="流程图"></p>
<h3 id="二-创建纯Java工程">二.创建纯Java工程</h3><p>1.通过 File -&gt; New -&gt; New Module -&gt; Java Library -&gt; 填写相应的包名与类名 -&gt; Finish.<br><img src="http://ww2.sinaimg.cn/large/005yEbTbgw1f4c78g5lpuj30cm0a0gnq.jpg" alt="流程图"><br><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f4c7fq5qpej30t40h9dic.jpg" alt="流程图"></p>
<p>2.配置新模块的 build.gradle，添加 dependencies.<br><img src="http://ww4.sinaimg.cn/large/005yEbTbgw1f4c7i0fi4fj30kv06aaaz.jpg" alt="流程图"></p>
<p>3.编写新模块的类用于生成java-gen下的DaoMaster、DaoSession、Dao、Entity类的生成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   public class DaoGen &#123;</span><br><span class="line"></span><br><span class="line">   public static  void main(String [] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       Schema schema = new Schema(1,"project.kylin.greendao");</span><br><span class="line"></span><br><span class="line">//EntityBean is Associated database table,table name is class name</span><br><span class="line">       Entity userBean = schema.addEntity("User");</span><br><span class="line"></span><br><span class="line">//add field</span><br><span class="line">      userBean.addIdProperty();</span><br><span class="line">      userBean.addStringProperty("uid").notNull();</span><br><span class="line">      userBean.addDateProperty("date");</span><br><span class="line"></span><br><span class="line">   //generator gao</span><br><span class="line">  	   new DaoGenerator().generateAll(schema,"app/src/main/java-gen");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-生成_DAO_文件">三.生成 DAO 文件</h3><ul>
<li>执行 java 工程，如一切正常，你将会在控制台看到如下日志，并且在主工程「java-gen」下会发现生成了DaoMaster、DaoSession、UserDao、User共4个类文件。(从console查看编译结果)  </li>
</ul>
<hr>
<h2 id="升级和比较">升级和比较</h2><h3 id="升级">升级</h3><ul>
<li><a href="http://blog.csdn.net/growth58/article/details/50453038" target="_blank" rel="external">GreenDao数据库升级解决方案</a> </li>
</ul>
<h3 id="性能比较">性能比较</h3><ul>
<li><a href="https://github.com/litesuits/for-test/blob/master/DataBaseTest/README.md" target="_blank" rel="external">GreenDao与LiteOrm</a></li>
</ul>
<hr>
<h2 id="参考文献">参考文献</h2><ul>
<li><a href="http://greendao-orm.com/" target="_blank" rel="external">官网</a></li>
<li><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">参考demo</a></li>
</ul>
<h2 id="其他开源的ORM">其他开源的ORM</h2><ul>
<li><a href="https://github.com/Raizlabs/DBFlow" target="_blank" rel="external">DBFlow</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="GreenDao官方简介">GreenDao官方简介</h2><p>greenDAO is an open source library for Android providing an easy to use interface to SQLite databases to help developers handle data efficiently – relieving developers from dealing with low-level database requirements while saving development time. SQLite is an awesome embedded relational database. Still, writing SQL and parsing query results are quite tedious and time-consuming tasks. greenDAO frees you from these by mapping Java objects to database tables (often called ORM). This way you can store, update, delete, and query for Java objects using a simple object oriented API.</p>
<h2 id="<!-more_->">]]>
    
    </summary>
    
      <category term="Android" scheme="http://walk-code.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rxjava入门]]></title>
    <link href="http://walk-code.github.io/2016/04/12/Rxjava%E5%85%A5%E9%97%A8/"/>
    <id>http://walk-code.github.io/2016/04/12/Rxjava入门/</id>
    <published>2016-04-12T15:27:10.000Z</published>
    <updated>2016-05-04T13:24:03.621Z</updated>
    <content type="html"><![CDATA[<p><strong>传送门</strong> <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="external">RxJava中文翻译</a>亦或<a href="http://reactivex.io/" target="_blank" rel="external">RxJava官方文档</a></p>
<h3 id="1-为什么要用RxJava">1.为什么要用RxJava</h3><p>这里引用一段<a href="https://realm.io/cn/news/kau-felipe-lima-adopting-rxjava-airbnb-android/" target="_blank" rel="external">Airbnb Developer</a>的一段话:</p>
<p>我们都知道 移动开发是困难的。移动用户期望即时响应，而且还有在不同的线程间来回切换的需求。除了主线程，你还要做网络连接，同时你还需要在后台处理其他的各种不同的事情。最重要的是，你不能阻塞 UI 线程。<br><a id="more"></a><br>RxJava 是解决这类问题的好方法，因为他能够使得线程间的切换比较容易。这已经集成在框架里面了。异步操作非常笨重而且容易出错，RxJava 使得你不用再这样做了，这也是你能把不同的线程组合在一起的原因。</p>
<p>我们需要 RxJava 的真正原因其实是 我们的软件很烂。为什么我们有如此多的 bug？为什么我们需要 crash 报告工具来跟踪我们成千上万的 crash，或者多少用户已经对我们生气了？这里可能有些什么事情不对劲。</p>
<p>我们需要改变；我觉得 imperative 编程是我们不应该采用的方法。当然，面向对象编程已经流行很多年了。它已经深入到了现代程序员的骨髓里了。每个人都盲目的使用它，但是它不是我们开发软件的必需品。</p>
<p>Functional 编程是 RxJava 里面的概念，而且我觉得用这种方法，代码更加健壮，而且永远不需要维护状态了。代码更加可靠而且你知道它一定工作。</p>
<p>底线：我们的问题是我们写了很多糟糕的代码，移动开发也是很困难的，而 RxJava 是解决这个问题的一个方案。</p>
<h3 id="2-什么是RxJava">2.什么是RxJava</h3><p>官方简介:</p>
<p>ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming.</p>
<p><img src="http://ww1.sinaimg.cn/large/005yEbTbgw1f2wongssb4j30u20ccabm.jpg" alt=""></p>
<p>废话不多说先来个Hello World.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//基本Observable</span><br><span class="line">Observable myObservable = Observable.create(new Observable.OnSubscribe() &#123;</span><br><span class="line"></span><br><span class="line">		public void call(Object sub) &#123;</span><br><span class="line">			((Subscriber)sub).onNext(<span class="string">"Hello World"</span>);</span><br><span class="line">			((Subscriber)sub).onCompleted();</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;); </span><br><span class="line"></span><br><span class="line">//被消费</span><br><span class="line">Subscriber subscriber = new Subscriber() &#123;</span><br><span class="line"></span><br><span class="line">		public void onCompleted() &#123;</span><br><span class="line">						</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void onError(Throwable arg0) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void onNext(Object arg0) &#123;</span><br><span class="line">			System.out.println((String)arg0);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">//上面代码所做的工作就是打印由Observable发送的字符串。现在我们有了myObservable和mySubscriber，就可以通过subscribe()函数把两者关联起来：	</span><br><span class="line">myObservable.subscribe(mySubscriber);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结合Jvav8的新特效代码会变得更加的简洁</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = (Observable) Observable.just("Hello World").subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><strong>传送门</strong> <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">RxJava中文翻译</a>亦或<a href="http://reactivex.io/">RxJava官方文档</a></p>
<h3 id="1-为什么要用RxJava">1.为什么要用RxJava</h3><p>这里引用一段<a href="https://realm.io/cn/news/kau-felipe-lima-adopting-rxjava-airbnb-android/">Airbnb Developer</a>的一段话:</p>
<p>我们都知道 移动开发是困难的。移动用户期望即时响应，而且还有在不同的线程间来回切换的需求。除了主线程，你还要做网络连接，同时你还需要在后台处理其他的各种不同的事情。最重要的是，你不能阻塞 UI 线程。<br>]]>
    
    </summary>
    
      <category term="笔记" scheme="http://walk-code.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git 项目上传步骤]]></title>
    <link href="http://walk-code.github.io/2016/01/18/git-%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E6%AD%A5%E9%AA%A4/"/>
    <id>http://walk-code.github.io/2016/01/18/git-项目上传步骤/</id>
    <published>2016-01-18T14:19:51.000Z</published>
    <updated>2016-05-08T07:54:52.898Z</updated>
    <content type="html"><![CDATA[<p>先初始化Git:<br><code>Git Bash</code></p>
<blockquote>
<ul>
<li><code>git config --global user.name &quot;Your Real Name&quot;</code>    //github的名字</li>
<li><code>git config --global user.email you@email.address</code> //github的账号</li>
</ul>
</blockquote>
<p>上传文件到GitHub，需要一个SSH的密钥，在shell中输入ssh-keygen -C ‘your@email.address’ -t rsa 会出现让你输入SSH密钥的存放位置，这个可以不用理会，直接回车使用默认路径。接着就是你想要的密码，SSHkey就生成了。找到SSH密钥存放的位置，打开id_rsa.pub复制里面的内容（notepad++或者记事本打开）原封不动的复制，接着直接在打开GitHub，添加add SSH key。<br><a id="more"></a><br>做完这些可以说已经基本配置完成了，现在就可以上传自己的代码了，在你想上传的文件的下先<code>git init here</code>也可以在GitBash中进入这个文件，输入<code>git init</code></p>
<blockquote>
<ul>
<li><code>git add</code> 选择你要添加到仓库的文件.</li>
<li><code>git commit -m &#39;first commit&#39;</code> 添加到仓库。</li>
</ul>
</blockquote>
<p><strong>-m</strong> 后面跟参数说明，将代码提交到GitHub会在代码文件信息上显示这个说明。</p>
<blockquote>
<ul>
<li><code>git remote add origin git@github.com:XXX/XXX.git</code></li>
<li><code>git push -u origin master</code>完成上传。</li>
</ul>
</blockquote>
<p>一些可能遇到的问题解决方式：</p>
<blockquote>
<ul>
<li><code>git remote add origin</code></li>
<li><code>git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git</code></li>
</ul>
</blockquote>
<p>提示出错信息：fatal: remote origin already exists.<br>解决办法如下：</p>
<blockquote>
<ol>
<li>先输入<code>git remote rm origin</code> </li>
<li>再输入<code>git remote add origin git@github.com:djqiang/gitdemo.git</code> 就不会报错了！ </li>
<li>如果输入<code>git remote rm origin</code><br>还是报错的话，error: Could not remove config section ‘remote.origin’.<br>我们需要修改gitconfig文件的内容.</li>
<li>找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc</li>
<li>找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！</li>
</ol>
</blockquote>
<p>如果输入<code>ssh -T git@github.com</code><br>出现错误提示：Permission denied (publickey). 因为新生成的key不能加入ssh就会导致连接不上github。<br>解决办法如下：</p>
<blockquote>
<ol>
<li>先输入<code>ssh-agent</code>，再输入<code>ssh-add ~/.ssh/id_key</code>，这样就可以了。</li>
<li>如果还是不行的话，输入<code>ssh-add ~/.ssh/id_key</code> 命令后出现报错Could not open a connection to your authentication agent.解决方法是key用Git<br>Gui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。</li>
<li>最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。</li>
</ol>
</blockquote>
<p>如果输入<code>git push origin master</code><br>提示出错信息：error:failed to push som refs to …….<br>解决办法如下：</p>
<blockquote>
<ol>
<li>先输入<code>git pull origin master</code> //先把远程服务器github上面的文件拉下来 </li>
<li>再输入<code>git push origin master</code></li>
<li>如果出现报错 fatal: Couldn’t find remote ref<br>master或者fatal: ‘origin’ does not appear to be a git repository以及fatal:<br>Could not read from remote repository. </li>
<li>则需要重新输入<code>git remote add origingit@github.com:djqiang/gitdemo.git</code> </li>
</ol>
</blockquote>
<p>其他问题解决方式可以参考：<br><a href="http://stackoverflow.com/questions/16128018/git-commit-and-automatically-add-all-untracked-files" target="_blank" rel="external">http://stackoverflow.com/questions/16128018/git-commit-and-automatically-add-all-untracked-files</a><br><a href="http://stackoverflow.com/questions/4181861/src-refspec-master-does-not-match-any-when-pushing-commits-in-git" target="_blank" rel="external">http://stackoverflow.com/questions/4181861/src-refspec-master-does-not-match-any-when-pushing-commits-in-git</a></p>
<p>另外提供一个Git简易使用说明：<a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="external">http://www.bootcss.com/p/git-guide/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先初始化Git:<br><code>Git Bash</code></p>
<blockquote>
<ul>
<li><code>git config --global user.name &quot;Your Real Name&quot;</code>    //github的名字</li>
<li><code>git config --global user.email you@email.address</code> //github的账号</li>
</ul>
</blockquote>
<p>上传文件到GitHub，需要一个SSH的密钥，在shell中输入ssh-keygen -C ‘your@email.address’ -t rsa 会出现让你输入SSH密钥的存放位置，这个可以不用理会，直接回车使用默认路径。接着就是你想要的密码，SSHkey就生成了。找到SSH密钥存放的位置，打开id_rsa.pub复制里面的内容（notepad++或者记事本打开）原封不动的复制，接着直接在打开GitHub，添加add SSH key。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[过程]]></title>
    <link href="http://walk-code.github.io/2015/12/06/%E8%BF%87%E7%A8%8B/"/>
    <id>http://walk-code.github.io/2015/12/06/过程/</id>
    <published>2015-12-06T14:27:34.000Z</published>
    <updated>2016-05-08T07:55:08.762Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>杂文</li>
</ul>
</blockquote>
<p>11月匆匆就这样子过去了，总体来说过得还算的上是充实，在工作上所面临的问题基本上就可以处理好。有时候过分的追求功能忽略了用户体验也是一件很糟糕的事，毕竟用户一看到一个”不友好”的界面，就会立马的删除掉，除了非常需要这个App除外。<br><a id="more"></a><br>最近一直都在忙这个项目，希望它能早日的上线，把程序里所有的BUG都消灭掉，在把自己的代码优化了，之前看到一篇Blog，讲到不要盲目的去优化自己的代码，在保证其功能实现并且没有任何BUG的情况下，才好进行优化，这样才不会造成越来越多的错误，一定要注意自己的开发的效率，有时候一个 问题困扰自己太久，你可以选择把它给记下来，我是用印象笔记的，有一些知识点比较稀疏的也可以用它记下来，有事没事多翻翻也就OK了。</p>
<p>拥有一个强大的身体才是，你能编程的前提，保证好自己每天的运动量，也就能好好的撸码了。最近在收集一下android的技能树，让自己的技能树更  加的完善起来。</p>
<p><img src="http://ww3.sinaimg.cn/large/005yEbTbgw1eyqbtb3zy5j30jx1n1wlq.jpg" alt="cmd-markdown-logo">    </p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<ul>
<li>杂文</li>
</ul>
</blockquote>
<p>11月匆匆就这样子过去了，总体来说过得还算的上是充实，在工作上所面临的问题基本上就可以处理好。有时候过分的追求功能忽略了用户体验也是一件很糟糕的事，毕竟用户一看到一个”不友好”的界面，就会立马的删除掉，除了非常需要这个App除外。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://walk-code.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android传递对象的三种方式]]></title>
    <link href="http://walk-code.github.io/2015/11/10/Android%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://walk-code.github.io/2015/11/10/Android传递对象的三种方式/</id>
    <published>2015-11-10T14:52:15.000Z</published>
    <updated>2016-10-10T05:18:12.730Z</updated>
    <content type="html"><![CDATA[<p>在Android中，Activity和Fragment、Activity和Fragment之间传递对象，可以通过对象序列化存入Intent,Bundle进行传递，也可以通过将对象转化成Json字符串，进行传递。<br>对象的序列化也可以通过使用Java的’Serializable’的接口、’Parcelable’接口(Android)。转化成’Json字符串’，可以使用Gson的类库。<br><a id="more"></a></p>
<h2 id="Serializable">Serializable</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Goods implements Serializable&#123;</span><br><span class="line">    private String images;</span><br><span class="line">	private String goods_name;</span><br><span class="line">	private double price;</span><br><span class="line">	private int stock;</span><br><span class="line">	private String details;</span><br><span class="line">	//setting&amp;getting method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Goods goods = new Goods();</span><br><span class="line">goods.setImages(...);</span><br><span class="line">goods.setPrice(...);</span><br><span class="line">       ....</span><br><span class="line">Intent intent = new Intent(this,Activity);</span><br><span class="line">intent.putExtra(<span class="string">"goods"</span>,goods);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>接收数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Goods goods = getIntent().getSerializableExtra(<span class="string">"goods"</span>);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h3 id="Json字符串">Json字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Goods goods = new Goods();</span><br><span class="line">goods.setImages(...);</span><br><span class="line">goods.setPrice(...);</span><br><span class="line">       ....</span><br><span class="line">Intent intent = new Intent(this,Activity);</span><br><span class="line">intent.putExtra(<span class="string">"goods"</span>,new Gson().toJson(goods</span><br><span class="line">startActivity();</span><br></pre></td></tr></table></figure>
<p>接收数据<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> String bookJson=getIntent().getStringExtra("book");</span><br><span class="line"> Book book=new Gson().fromJson(bookJson,Book.class);</span><br><span class="line">``` </span><br><span class="line">### Parcelable</span><br><span class="line"></span><br><span class="line">实现'Parcelable'接口需要实现两个方法</span><br><span class="line"></span><br><span class="line">describeContents方法。内容接口描述，通常返回0;</span><br><span class="line"></span><br><span class="line">writeToParce方法。将传递的数据打包到Parcel容器中。</span><br><span class="line"></span><br><span class="line">除了要实现这两个方法还必须创建一个'Parcelable.Creator'接口的实例，用于读取Parcel容器中的数据。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">public class Goods implements Parcelable&#123;</span><br><span class="line">    private String images;</span><br><span class="line">	private String goods_name;</span><br><span class="line">	private double price;</span><br><span class="line">	private int stock;</span><br><span class="line">	private String details;</span><br><span class="line">	//setting&amp;getting </span><br><span class="line">	</span><br><span class="line">	 @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line"> </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        //该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存，</span><br><span class="line">        // 以便从parcel容器获取数据</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    public static final Creator&lt;Goods&gt; CREATOR=new Creator&lt;Goods&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Goods createFromParcel(Parcel source) &#123;</span><br><span class="line">            //从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。</span><br><span class="line">            Goods goods = new Goods();</span><br><span class="line">            goods.setGoods_Name(source.readString());</span><br><span class="line">            goods.setPrice(source.readDouable());</span><br><span class="line">			    ...</span><br><span class="line">            return goods;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public Author[] newArray(int size) &#123;</span><br><span class="line">            //创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。</span><br><span class="line">            return new Goods[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传递数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Goods goods = new Goods();</span><br><span class="line">goods.setImages(...);</span><br><span class="line">goods.setPrice(...);</span><br><span class="line">       ....</span><br><span class="line">Intent intent = new Intent(this,Activity);</span><br><span class="line">intent.putExtra(<span class="string">"goods"</span>,goods);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>接收数据</p>
<pre><code class="python">Goods goods = getIntent().getParcelableExtra(<span class="string">"book"</span>);
.....
</code></pre>
<p>同样的是对对象进行序列化，’Serializable’与’Parcelable’有哪些区别。</p>
<h3 id="Serializable与Parcelable区别">Serializable与Parcelable区别</h3><p>先看看这张图:<br><img src="http://www.jcodecraeer.com/uploads/20150104/1420344818993474.png" alt="file-list"><br>消耗的时间关系 字符串&gt;Serializable&gt;Parcelable ,从性能上看我们会优先选择’Parcelable’,从上面代码可以看出使用’Parcelable’有大量重复的模板代码。</p>
<h3 id="简化Parcel操作">简化Parcel操作</h3><p>如果你使用android Studio 可以通过安装android-parcelable-intellij-plugin插件，或者自己配置模板进行操作。</p>
<h3 id="区别"><a href="http://greenrobot.me/devpost/android-parcelable-serializable/" target="_blank" rel="external">区别</a></h3><p>‘Serializable is a standard Java interface. You simply mark a class Serializable by implementing the interface, and Java will automatically serialize it in certain situations.</p>
<p>Parcelable is an Android specific interface where you implement the serialization yourself. It was created to be far more efficient that Serializable, and to get around some problems with the default Java serialization scheme.</p>
<p>I believe that Binder and AIDL work with Parcelable objects.</p>
<p>However, you can use Serializable objects in Intents’<br>上文的意思指Serializable是java提供的接口，Parcelable是Google提供的接口,在AIDL(Android内部进程通讯接口)和Binder(进程通讯机制)中会用到Parcelable，无论怎样’Serializable’对象都能在Intent中使用。 Serializable简单易用，Parcelable速度至上</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android中，Activity和Fragment、Activity和Fragment之间传递对象，可以通过对象序列化存入Intent,Bundle进行传递，也可以通过将对象转化成Json字符串，进行传递。<br>对象的序列化也可以通过使用Java的’Serializable’的接口、’Parcelable’接口(Android)。转化成’Json字符串’，可以使用Gson的类库。<br>]]>
    
    </summary>
    
      <category term="笔记" scheme="http://walk-code.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
